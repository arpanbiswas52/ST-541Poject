
#' Simulation of Storage 
#'
#' Generating total \code{2*ntimes+1} storage simulations for each of \code{t} days optimization period
#' 
#'
#' Generating total \code{2*ntimes+1} storage simulations for each of \code{t} days optimization period.
#' The first \code{ntimes} rows are the simulations for GrandCoulee, next \code{ntimes} rows are the simulations for Lower Granite
#' and the last row of the matrix is the deterministic Storage data for McNaire. McNaire Inflows doesnot have any uncertainity
#' since it is the total outflows released from GCL and LWG which are deterministic. In future, we can introduce other source
#' of uncertainity in the inflows of McNaire.
#' This function is required to quantify the unertainity on Storage of Grand Coulle and Lower Granite.
#' Also, the result from this function is required to simulate forebay elevation.
#'
#' @param Inflow1 A large matrix of \code{ntimes} simulations of Inflows of GCL for \code{t} = 14 days. Each rows
#' represent a single realization and each columns represent the time steps,\code{t} in days 
#' @param Inflow2 A large matrix of \code{ntimes} simulations of Inflows of LWG for \code{t} = 14 days. Each rows
#' represent a single realization and each columns represent the time steps,\code{t} in days    
#' @param Storage_initial A vector of length 3 with initial/current storage of Grand Coulee, Lower Granite and McNaire.
#' for all \code{t} days. This is provided in the model as initial condition of the optimization.
#' @param Inflow_initial A vector of length 3 with initial/current inflows of Grand Coulee, Lower Granite and McNaire.
#' for all \code{t} days. This is provided in the model as initial condition of the optimization.
#' @param Outflow_initial A vector of length 3 with initial/current outflows of Grand Coulee, Lower Granite and McNaire.
#' for all \code{t} days. This is provided in the model as initial condition of the optimization.
#' @param Outflows The is the matrix tranformation of outflows data (decision variables) generated by SQP algorithm in a vector form.
#' where each column is the day for \code{t} days optimization period. The rows represents the outflows of GCL,
#' LWG and MCN respectively.
#' \code{Outflows} = 14*3 = 42 
#' @param delta_t This is value of time-step in day. In our problem, we have considered daily timesteps for optimization.
#' Therefore, \code{delta_t} =1
#' @param t An integer indicating the number of timesteps. If we consider daily timestep for 14 day optimization
#' period, \code{t} = 14. 
#' @param ntimes An integer indicating the number of simulations/realizations.
#'
#' @return A large matrix of \code{2*ntimes+1} simulations/realizations for Storage. Each rows
#' represent a single realization, \code{2*ntimes+1} and each columns represent the time steps,\code{t} in days   
#' The first \code{ntimes} rows are the simulations for GrandCoulee, next \code{ntimes} rows are the simulations for Lower Granite
#' and the last row of the matrix is the deterministic Storage data for McNaire. McNaire Inflows doesnot have any uncertainity
#' since it is the total outflows released from GCL and LWG which are deterministic. In future, we can introduce other source
#' of uncertainity in the inflows of McNaire.
#' @export
#'
#' @examples
#' Inflow1 <- GCLInflowsdata_samples
#' Inflow2 <- LWGInflowsdata_samples
#' Storage_initial <- Current_Storage
#' Inflow_initial <- Current_Inflows
#' Outflow_initial <- Current_Outflows
#' Outflows <- Outflows_matrixform
#' delta_t <- 1
#' t <- 14
#' ntimes <-100
#' Storage_realizations(Inflow1, Inflow2, Storage_initial, Inflow_initial, Outflow_initial, Outflows, delta_t, t, ntimes)

Storage_realizations <- function(Inflow1, Inflow2, Storage_initial, Inflow_initial, Outflow_initial, Outflows, delta_t, t, ntimes){
  n<-ntimes
  #browser()
  GCLInflowsdata_samples <- Inflow1
  LWGInflowsdata_samples <- Inflow2
  V_in <- Storage_initial
  I_in <- Inflow_initial
  Q_in <- Outflow_initial
  Q_GCL <- Outflows[1, ]
  Q_LWG <- Outflows[2, ]
  Q_MCN <- Outflows[3, ]
  MCNInflows <- Outflows[1, ] + Outflows[2, ]
  Storage_realizations_GCL <- matrix(0L, nrow =n, ncol = t)
  Storage_realizations_LWG <- matrix(0L, nrow =n, ncol = t)
  Storage_realizations_MCN <- matrix(0L, nrow =1, ncol = t)
  #browser()
  #1st timestep
  Storage_realizations_GCL[, 1] <- ((I_in[1] + GCLInflowsdata_samples[, 1])*0.5) + ((Q_in[1] + Q_GCL[1])*0.5)*delta_t + V_in[1]
  
  Storage_realizations_LWG[, 1] <- ((I_in[2] + LWGInflowsdata_samples[, 1])*0.5 + (Q_in[2] + Q_LWG[1])*0.5)*delta_t + V_in[2]
  
  Storage_realizations_MCN[, 1] <- ((I_in[3] + MCNInflows[1])*0.5 + (Q_in[3] + Q_MCN[1])*0.5)*delta_t + V_in[3]
  
  #Rest of the timesteps
  
  for (i in 2:t){
    Storage_realizations_GCL[, i] <- ((GCLInflowsdata_samples[, i-1] + GCLInflowsdata_samples[, i])*0.5 + (Q_GCL[i-1] + Q_GCL[i])*0.5)*delta_t +Storage_realizations_GCL[, i-1]
    
    Storage_realizations_LWG[, i] <- ((LWGInflowsdata_samples[, i-1] + LWGInflowsdata_samples[, i])*0.5 + (Q_LWG[i-1] + Q_LWG[i])*0.5)*delta_t +Storage_realizations_LWG[, i-1]
    
    Storage_realizations_MCN[i] <- ((MCNInflows[i-1] + MCNInflows[i])*0.5 + (Q_MCN[i-1] + Q_MCN[i])*0.5)*delta_t +Storage_realizations_MCN[i-1]
  }
  #browser()
  Storage_realizations <- rbind(Storage_realizations_GCL, Storage_realizations_LWG, Storage_realizations_MCN)
  
}


#' Simulation of Forebay Elevation 
#'
#' Generating total \code{2*ntimes+1} Forebay simulations for each of \code{t} days optimization period
#' 
#'
#' Generating total \code{2*ntimes+1} Forebay simulations for each of \code{t} days optimization period.
#' The first \code{ntimes} rows are the simulations for GrandCoulee, next \code{ntimes} rows are the simulations for Lower Granite
#' and the last row of the matrix is the deterministic Forebay data for McNaire. McNaire Inflows doesnot have any uncertainity
#' since it is the total outflows released from GCL and LWG which are deterministic. In future, we can introduce other source
#' of uncertainity in the inflows of McNaire.
#' This function is required to quantify the unertainity on Forebay of Grand Coulle and Lower Granite.
#' Also, the result from this function is required to simulate Tailwater and Head.
#'
#' @param Storage_largerealizations A large matrix of \code{2*ntimes+1} simulations/realizations for Storage. Each rows
#' represent a single realization, \code{ntimes} and each columns represent the time steps,\code{t} in days   
#' The first \code{ntimes} rows are the simulations for GrandCoulee, next \code{ntimes} rows are the simulations for Lower Granite
#' and the last row of the matrix is the deterministic Storage data for McNaire. McNaire Inflows doesnot have any uncertainity
#' since it is the total outflows released from GCL and LWG which are deterministic. In future, we can introduce other source
#' of uncertainity in the inflows of McNaire.
#' @param Fb_coeff This is coefficients to calculate the Forebay. The coefficients are provided as input data and the values
#' has been obtained separately by the regression model. Each row is the coefficient data for GCL, LWG and MCN respectively.
#' @param t An integer indicating the number of timesteps. If we consider daily timestep for 14 day optimization
#' period, \code{t} = 14. 
#' @param ntimes An integer indicating the number of simulations/realizations.
#'
#' @return A large matrix of \code{2*ntimes+1} simulations/realizations for Forebay. Each rows
#' represent a single realization, \code{2*ntimes+1} and each columns represent the time steps,\code{t} in days   
#' The first \code{ntimes} rows are the simulations for GrandCoulee, next \code{ntimes} rows are the simulations for Lower Granite
#' and the last row of the matrix is the deterministic Forebay data for McNaire. McNaire Inflows doesnot have any uncertainity
#' since it is the total outflows released from GCL and LWG which are deterministic. In future, we can introduce other source
#' of uncertainity in the inflows of McNaire.
#' @export
#'
#' @examples
#' Storage_largerealizations <- Storage_largerealizations
#' Fb_coeff <- Fb_coeff
#' t <- 14
#' ntimes <-100
#' Forebay_realizations(Storage_largerealizations, Fb_coeff, t, ntimes)

Forebay_realizations <- function(Storage_largerealizations, Fb_coeff, t, ntimes){
  n<- ntimes
  Storage_realizations_GCL <- Storage_largerealizations[1:n,]
  Storage_realizations_LWG <- Storage_largerealizations[(n+1):(2*n),]
  Storage_realizations_MCN <- Storage_largerealizations[(2*n)+1,]
  Forebay_realizations_GCL <- matrix(0L, nrow =n, ncol = t)
  Forebay_realizations_LWG <- matrix(0L, nrow =n, ncol = t)
  Forebay_realizations_MCN <- matrix(0L, nrow =1, ncol = t)
  
  Forebay_realizations_GCL <- Fb_coeff[1,1]* Storage_realizations_GCL^2 + Fb_coeff[1,2]* Storage_realizations_GCL + Fb_coeff[1,3]
  
  Forebay_realizations_LWG <- Fb_coeff[2,1]* Storage_realizations_LWG^2 + Fb_coeff[2,2]* Storage_realizations_LWG + Fb_coeff[2,3]
  
  Forebay_realizations_MCN <- Fb_coeff[3,1]* Storage_realizations_MCN^2 + Fb_coeff[3,2]* Storage_realizations_MCN + Fb_coeff[3,3]
  
  Forebay_realizations <- rbind(Forebay_realizations_GCL, Forebay_realizations_LWG, Forebay_realizations_MCN)
}




#' Simulation of Tailwater Elevation 
#'
#' Generating total \code{2*ntimes+1} Tailwater simulations for each of \code{t} days optimization period
#' 
#'
#' Generating total \code{2*ntimes+1} Tailwater simulations for each of \code{t} days optimization period.
#' The first \code{ntimes} rows are the simulations for GrandCoulee, next \code{ntimes} rows are the simulations for Lower Granite
#' and the last row of the matrix is the deterministic Tailwater data for McNaire. McNaire Inflows doesnot have any uncertainity
#' since it is the total outflows released from GCL and LWG which are deterministic. In future, we can introduce other source
#' of uncertainity in the inflows of McNaire.
#' This function is required to quantify the unertainity on Tailwater of Grand Coulle and Lower Granite.
#' Also, the result from this function is required to simulate Head.
#'
#' @param Forebay_largerealizations A large matrix of \code{2*ntimes+1} simulations/realizations for Forebay. Each rows
#' represent a single realization, \code{ntimes} and each columns represent the time steps,\code{t} in days   
#' The first \code{ntimes} rows are the simulations for GrandCoulee, next \code{ntimes} rows are the simulations for Lower Granite
#' and the last row of the matrix is the deterministic Tailwater data for McNaire. McNaire Inflows doesnot have any uncertainity
#' since it is the total outflows released from GCL and LWG which are deterministic. In future, we can introduce other source
#' of uncertainity in the inflows of McNaire.
#' @param Outflow_initial A vector of length 3 with initial/current outflows of Grand Coulee, Lower Granite and McNaire.
#' for all \code{t} days. This is provided in the model as initial condition of the optimization.
#' @param Forebay_initial A vector of length 3 with initial/current forebay of Grand Coulee, Lower Granite and McNaire.
#' for all \code{t} days. This is provided in the model as initial condition of the optimization.
#' @param Tailwater_initial A vector of length 3 with initial/current tailwater of Grand Coulee, Lower Granite and McNaire.
#' for all \code{t} days. This is provided in the model as initial condition of the optimization.
#' @param Tw_coeff This is coefficients to calculate the Tailwater. The coefficients are provided as input data and the values
#' has been obtained separately by the regression model. Each column is the coefficient data for GCL, LWG and MCN respectively.
#' @param Outflows The is the matrix tranformation of outflows data (decision variables) generated by SQP algorithm in a vector form.
#' where each column is the day for \code{t} days optimization period. The rows represents the outflows of GCL,
#' LWG and MCN respectively.
#' @param t An integer indicating the number of timesteps. If we consider daily timestep for 14 day optimization
#' period, \code{t} = 14. 
#' @param ntimes An integer indicating the number of simulations/realizations.
#'
#' @return A large matrix of \code{2*ntimes+1} simulations/realizations for Tailwater. Each rows
#' represent a single realization, \code{2*ntimes+1} and each columns represent the time steps,\code{t} in days   
#' The first \code{ntimes} rows are the simulations for GrandCoulee, next \code{ntimes} rows are the simulations for Lower Granite
#' and the last row of the matrix is the deterministic Tailwater data for McNaire. McNaire Inflows doesnot have any uncertainity
#' since it is the total outflows released from GCL and LWG which are deterministic. In future, we can introduce other source
#' of uncertainity in the inflows of McNaire.
#' @export
#'
#' @examples
#' Forebay_largerealizations <- Forebay_largerealizations
#' Outflow_initial <- Current_Outflows
#' Forebay_initial <- Current_Forebay
#' Tailwater_initial <- Current_Tailwater
#' Tw_coeff <- Tw_coeff
#' Outflows <- Outflows_matrixform
#' t <- 14
#' ntimes <-100
#' Tailwater_realizations(Forebay_largerealizations, Outflow_initial, Forebay_initial, Tailwater_initial, Tw_coeff, Outflows, t, ntimes)

Tailwater_realizations <- function(Forebay_largerealizations, Outflow_initial, Forebay_initial, Tailwater_initial, Tw_coeff, Outflows, t, ntimes){
n<- ntimes
  Q_GCL <- Outflows[1, ]
  Q_LWG <- Outflows[2, ]
  Q_MCN <- Outflows[3, ]
  Q_in <- Outflow_initial
  Fb_in <- Forebay_initial
  Tw_in <- Tailwater_initial
  Tailwater_realizations_GCL <- matrix(0L, nrow =n, ncol = t)
  Tailwater_realizations_LWG <- matrix(0L, nrow =n, ncol = t)
  Tailwater_realizations_MCN <- matrix(0L, nrow =1, ncol = t)
  
  #1st timestep
  Tailwater_realizations_GCL[, 1] <- Tw_coeff[1,1] + Tw_coeff[2,1]*Q_GCL[1] +Tw_coeff[3,1]*Fb_in[3]
  
  Tailwater_realizations_LWG[, 1] <- Tw_coeff[1,2] + Tw_coeff[2,2]*Q_LWG[1] +Tw_coeff[3,2]*Fb_in[3]
  
  Tailwater_realizations_MCN[, 1] <- Tw_coeff[1,3] + Tw_coeff[2,3]*Tw_in[3] +Tw_coeff[3,3]*(Q_MCN[1] - Q_in[3])
  
  
  #Rest of the timestep
  
  for (i in 2:t){
    Tailwater_realizations_GCL[, i] <- Tw_coeff[1,1] + Tw_coeff[2,1]*Q_GCL[i] + Tw_coeff[3,1]*Forebay_largerealizations[(2*n)+1, i-1]
    
    Tailwater_realizations_LWG[, i] <- Tw_coeff[1,2] + Tw_coeff[2,2]*Q_LWG[i] + Tw_coeff[3,2]*Forebay_largerealizations[(2*n)+1, i-1]
    
    Tailwater_realizations_MCN[, i] <- Tw_coeff[1,3] + Tw_coeff[2,3]*Tailwater_realizations_MCN[, i-1] +Tw_coeff[3,3]*(Q_MCN[i] - Q_MCN[i-1])
  }
  
  Tailwater_realizations <- rbind(Tailwater_realizations_GCL, Tailwater_realizations_LWG, Tailwater_realizations_MCN)
}

#' Simulation of Head 
#'
#' Generating total \code{2*ntimes+1} Head simulations for each of \code{t} days optimization period
#' 
#'
#' Generating total \code{2*ntimes+1} Head simulations for each of \code{t} days optimization period.
#' The first \code{ntimes} rows are the simulations for GrandCoulee, next \code{ntimes} rows are the simulations for Lower Granite
#' and the last row of the matrix is the deterministic Head data for McNaire. McNaire Inflows doesnot have any uncertainity
#' since it is the total outflows released from GCL and LWG which are deterministic. In future, we can introduce other source
#' of uncertainity in the inflows of McNaire.
#' This function is required to quantify the unertainity on Head of Grand Coulle and Lower Granite.
#' Also, the result from this function is required to simulate Energy generation.
#'
#' @param Forebay_largerealizations A large matrix of \code{2*ntimes+1} simulations/realizations for Forebay. Each rows
#' represent a single realization, \code{ntimes} and each columns represent the time steps,\code{t} in days   
#' The first \code{ntimes} rows are the simulations for GrandCoulee, next \code{ntimes} rows are the simulations for Lower Granite
#' and the last row of the matrix is the deterministic Forebay data for McNaire. McNaire Inflows doesnot have any uncertainity
#' since it is the total outflows released from GCL and LWG which are deterministic. In future, we can introduce other source
#' of uncertainity in the inflows of McNaire.
#' @param Tailwater_largerealizations A large matrix of \code{2*ntimes+1} simulations/realizations for Tailwater. Each rows
#' represent a single realization, \code{ntimes} and each columns represent the time steps,\code{t} in days   
#' The first \code{ntimes} rows are the simulations for GrandCoulee, next \code{ntimes} rows are the simulations for Lower Granite
#' and the last row of the matrix is the deterministic Tailwater data for McNaire. McNaire Inflows doesnot have any uncertainity
#' since it is the total outflows released from GCL and LWG which are deterministic. In future, we can introduce other source
#' of uncertainity in the inflows of McNaire.
#'
#' @return A large matrix of \code{2*ntimes+1} simulations/realizations for Head. Each rows
#' represent a single realization, \code{2*ntimes+1} and each columns represent the time steps,\code{t} in days   
#' The first \code{ntimes} rows are the simulations for GrandCoulee, next \code{ntimes} rows are the simulations for Lower Granite
#' and the last row of the matrix is the deterministic Head data for McNaire. McNaire Inflows doesnot have any uncertainity
#' since it is the total outflows released from GCL and LWG which are deterministic. In future, we can introduce other source
#' of uncertainity in the inflows of McNaire.
#' @export
#'
#' @examples
#' Forebay_largerealizations <- Forebay_largerealizations
#' Tailwater_largerealizations <- Tailwater_largerealizations
#' Head_realizations(Forebay_largerealizations, Tailwater_largerealizations)


Head_realizations <- function(Forebay_largerealizations, Tailwater_largerealizations){
  
  Head_realizations <- Forebay_largerealizations - Tailwater_largerealizations
}


#' Simulation of Energy generation 
#'
#' Generating total \code{2*ntimes+1} Energy generation simulations for each of \code{t} days optimization period
#' 
#'
#' Generating total \code{2*ntimes+1} Energy generation simulations for each of \code{t} days optimization period.
#' The first \code{ntimes} rows are the simulations for GrandCoulee, next \code{ntimes} rows are the simulations for Lower Granite
#' and the last row of the matrix is the deterministic Energy generation data for McNaire. McNaire Inflows doesnot have any uncertainity
#' since it is the total outflows released from GCL and LWG which are deterministic. In future, we can introduce other source
#' of uncertainity in the inflows of McNaire.
#' This function is required to quantify the unertainity on Energy generation of Grand Coulle and Lower Granite.
#' Also, the result from this function is required to simulate Revenue.
#'
#' @param Head_largerealizations A large matrix of \code{2*ntimes+1} simulations/realizations for Head. Each rows
#' represent a single realization, \code{ntimes} and each columns represent the time steps,\code{t} in days   
#' The first \code{ntimes} rows are the simulations for GrandCoulee, next \code{ntimes} rows are the simulations for Lower Granite
#' and the last row of the matrix is the deterministic Head data for McNaire. McNaire Inflows doesnot have any uncertainity
#' since it is the total outflows released from GCL and LWG which are deterministic. In future, we can introduce other source
#' of uncertainity in the inflows of McNaire.
#' @param Outflows The is the matrix tranformation of outflows data (decision variables) generated by SQP algorithm in a vector form.
#' where each column is the day for \code{t} days optimization period. The rows represents the outflows of GCL,
#' LWG and MCN respectively.
#' @param efficiency This is considered as 0.75.
#' @param t An integer indicating the number of timesteps. If we consider daily timestep for 14 day optimization
#' period, \code{t} = 14. 
#' @param ntimes An integer indicating the number of simulations/realizations.
#' 
#' @return A large matrix of \code{2*ntimes+1} simulations/realizations for Energy generation. Each rows
#' represent a single realization, \code{2*ntimes+1} and each columns represent the time steps,\code{t} in days   
#' The first \code{ntimes} rows are the simulations for GrandCoulee, next \code{ntimes} rows are the simulations for Lower Granite
#' and the last row of the matrix is the deterministic Energy generation data for McNaire. McNaire Inflows doesnot have any uncertainity
#' since it is the total outflows released from GCL and LWG which are deterministic. In future, we can introduce other source
#' of uncertainity in the inflows of McNaire.
#' @export
#'
#' @examples
#' Head_largerealizations <- Head_largerealizations
#' Outflows <- Outflows_matrixform
#' efficiency <- 0.75
#' t <- 14
#' ntimes <-100

Energy_realizations <- function(Head_largerealizations, Outflows, efficieny, t, ntimes){
  e <- efficieny
  n<- ntimes
  Q_GCL <- Outflows[1, ] %>% rep(n) %>% matrix(nrow = n, byrow = TRUE)
  Q_LWG <- Outflows[2, ] %>% rep(n) %>% matrix(nrow = n, byrow = TRUE)
  Q_MCN <- Outflows[3, ]
  Q_out <- rbind(Q_GCL, Q_LWG, Q_MCN) 
  g <- 9.81
  Energy_realizations <- e*Head_largerealizations*0.3048*Q_out*28.31684*g*10^-3
}


#' Quantifying means and standard deviations using Antithetic Variable approach.
#'
#' Quantifying means and standard deviations for Storage, Forebay, Tailwater, Head and Energy generation 
#' using Antithetic Variable approach.
#' 
#'
#' Quantifying means and standard deviations for Storage, Forebay, Tailwater, Head and Energy generation 
#' using Antithetic Variable approach. This function is required to evaluate robust objective function and validate
#' probabilistic constraints
#'
#' @param samples A large list of \code{ntimes} random normal samples of Inflows and \code{ntimes^2} random uniform samples of Price for \code{t} = 14 days.
#' For example, in the samples of Inflows to Grand Coulle reservoir (GCLInflowsdata_samples)
#' inside the list, each rows represent a single realization, \code{ntimes} and each columns represent the time steps,\code{t} in days 
#' @param Storage_initial A vector of length 3 with initial/current storage of Grand Coulee, Lower Granite and McNaire.
#' for all \code{t} days. This is provided in the model as initial condition of the optimization.
#' @param Inflow_initial A vector of length 3 with initial/current inflows of Grand Coulee, Lower Granite and McNaire.
#' for all \code{t} days. This is provided in the model as initial condition of the optimization.
#' @param Outflow_initial A vector of length 3 with initial/current outflows of Grand Coulee, Lower Granite and McNaire.
#' for all \code{t} days. This is provided in the model as initial condition of the optimization.
#' @param Forebay_initial A vector of length 3 with initial/current forebay of Grand Coulee, Lower Granite and McNaire.
#' for all \code{t} days. This is provided in the model as initial condition of the optimization.
#' @param Tailwater_initial A vector of length 3 with initial/current tailwater of Grand Coulee, Lower Granite and McNaire.
#' for all \code{t} days. This is provided in the model as initial condition of the optimization.
#' @param Outflows The is the matrix tranformation of outflows data (decision variables) generated by SQP algorithm in a vector form.
#' where each column is the day for \code{t} days optimization period. The rows represents the outflows of GCL,
#' LWG and MCN respectively.
#' @param Fb_coeff This is coefficients to calculate the Forebay. The coefficients are provided as input data and the values
#' has been obtained separately by the regression model. Each row is the coefficient data for GCL, LWG and MCN respectively. 
#' @param Tw_coeff This is coefficients to calculate the Tailwater. The coefficients are provided as input data and the values
#' has been obtained separately by the regression model. Each column is the coefficient data for GCL, LWG and MCN respectively.
#' @param delta_t This is value of time-step in day. In our problem, we have considered daily timesteps for optimization.
#' Therefore, \code{delta_t} =1
#' @param efficiency This is considered as 0.75.
#' @param t An integer indicating the number of timesteps. If we consider daily timestep for 14 day optimization
#' period, \code{t} = 14. 
#' @param r An integer indicating the number of reservoirs. In this case study, \code{r}=3
#' @param n_samples An integer indicating the number of simulations/realizations.
#' 
#'
#' @return A large list of simulations along with the mean and standard deviation
#' for Storage, Forebay, Energy etc. For example, in the simulation matrix of Energy (Energy_realizations) inside the list, each rows
#' represent a single realization, \code{2*ntimes+1} and each columns represent the time steps,\code{t} in days.
#' The first \code{ntimes} rows are the simulations for GrandCoulee, next \code{ntimes} rows are the simulations for Lower Granite
#' and the last row of the matrix is the deterministic Energy generation data for McNaire. McNaire Inflows doesnot have any uncertainity
#' since it is the total outflows released from GCL and LWG which are deterministic. In future, we can introduce other source
#' of uncertainity in the inflows of McNaire.  
#' @export
#'
#' @examples
#' samples <- samples
#' Storage_initial <- Current_Storage
#' Inflow_initial <- Current_Inflows
#' Outflow_initial <- Current_Outflows
#' Forebay_initial <- Current_Forebay
#' Tailwater_initial <- Current_Tailwater
#' Outflows <- Outflows_matrixform
#' Fb_coeff <- Fb_coeff
#' Tw_coeff <- Tw_coeff
#' delta_t <- 1
#' efficieny <- 0.75
#' t <- 14
#' r<- 3
#' n_samples <-500
#' mean_sd_sim_antithetic(samples, Storage_initial, Inflow_initial, Outflow_initial,  Forebay_initial, Tailwater_initial, Outflows, Fb_coeff, Tw_coeff, delta_t, efficieny, t, r, n_samples)


mean_sd_sim_antithetic <- function(samples, Storage_initial, Inflow_initial, Outflow_initial,  Forebay_initial, Tailwater_initial, Outflows, Fb_coeff, Tw_coeff, delta_t, efficieny, t, r, n_samples){
  #Antithetic approach
  GCLInflowsdata_samples<- samples$GCLInflowsdata_samples
  LWGInflowsdata_samples<- samples$LWGInflowsdata_samples
  
  Storage_largerealizations <- Storage_realizations(GCLInflowsdata_samples, LWGInflowsdata_samples, Storage_initial, Inflow_initial, Outflow_initial, Outflows, delta_t, t, n_samples)
  
  #browser()
  Forebay_largerealizations <- Forebay_realizations(Storage_largerealizations, Fb_coeff, t, n_samples)
  
  Tailwater_largerealizations <- Tailwater_realizations(Forebay_largerealizations, Outflow_initial,  Forebay_initial, Tailwater_initial, Tw_coeff, Outflows, t, n_samples)
  
  Head_largerealizations <- Head_realizations(Forebay_largerealizations, Tailwater_largerealizations)
  
  Energy_largerealizations <- Energy_realizations(Head_largerealizations, Outflows, efficieny, t, n_samples)
  n <- n_samples
  
  Storage_mean <- matrix(0L, nrow =r, ncol = t)
  #Storage_mean2 <- matrix(0L, nrow =r, ncol = t)
  Storage_sd <- matrix(0L, nrow =r, ncol = t)
  Forebay_mean <- matrix(0L, nrow =r, ncol = t)
  #Forebay_mean2 <- matrix(0L, nrow =r, ncol = t)
  Forebay_sd <- matrix(0L, nrow =r, ncol = t)
  Energy_mean <- matrix(0L, nrow =r, ncol = t)
  #Energy_mean2 <- matrix(0L, nrow =r, ncol = t)
  Energy_sd <- matrix(0L, nrow =r, ncol = t)
  
  pair_average <- function(x1, x2){
    1/2 * (x1 + x2)
  }
  
  pair_averages_Storage_GCL <- pair_average(Storage_largerealizations[1:(n/2), ], Storage_largerealizations[((n/2)+1):n, ])
  pair_averages_Storage_LWG <- pair_average(Storage_largerealizations[(n+1):((n/2)+n), ], Storage_largerealizations[((n/2)+n+1) :(2*n), ])
  
  
  Storage_mean[1, ] <- colMeans(pair_averages_Storage_GCL)
  Storage_mean[2, ] <- colMeans(pair_averages_Storage_LWG)
  Storage_mean[3, ] <- (Storage_largerealizations[(2*n)+1, ])
  #Storage_mean2[1, ] <- colMeans(pair_averages_Storage_GCL^2)
  #Storage_mean2[2, ] <- colMeans(pair_averages_Storage_LWG^2)
  #Storage_mean2[3, ] <- (Storage_largerealizations[(2*n)+1, ]^2)
  
  #Storage_sd <- sqrt(Storage_mean2 - (Storage_mean^2))
  
  
  
  pair_averages_Forebay_GCL <- pair_average(Forebay_largerealizations[1:(n/2), ], Forebay_largerealizations[((n/2)+1):n, ])
  pair_averages_Forebay_LWG <- pair_average(Forebay_largerealizations[(n+1):((n/2)+n), ], Forebay_largerealizations[((n/2)+n+1) :(2*n), ])
  
  Forebay_mean[1, ] <- colMeans(pair_averages_Forebay_GCL)
  Forebay_mean[2, ] <- colMeans(pair_averages_Forebay_LWG)
  Forebay_mean[3, ] <- (Forebay_largerealizations[(2*n)+1, ])
  #Forebay_mean2[1, ] <- colMeans(pair_averages_Forebay_GCL^2)
  #Forebay_mean2[2, ] <- colMeans(pair_averages_Forebay_LWG^2)
  #Forebay_mean2[3, ] <- (Forebay_largerealizations[(2*n)+1, ]^2)
  
  # Forebay_sd <- sqrt(Forebay_mean2 - (Forebay_mean^2))
  
  pair_averages_Energy_GCL <- pair_average(Energy_largerealizations[1:(n/2), ], Forebay_largerealizations[((n/2)+1):n, ])
  pair_averages_Energy_LWG <- pair_average(Energy_largerealizations[(n+1):((n/2)+n), ], Forebay_largerealizations[((n/2)+n+1):(2*n), ])
  
  Energy_mean[1, ] <- colMeans(pair_averages_Energy_GCL)
  Energy_mean[2, ] <- colMeans(pair_averages_Energy_LWG)
  Energy_mean[3, ] <- (Energy_largerealizations[(2*n)+1, ])
  # Energy_mean2[1, ] <- colMeans(pair_averages_Energy_GCL^2)
  #Energy_mean2[2, ] <- colMeans(pair_averages_Energy_LWG^2)
  #Energy_mean2[3, ] <- (Energy_largerealizations[(2*n)+1, ]^2)
  
  # Energy_sd <- sqrt(Energy_mean2 - (Energy_mean^2))
  
  for (i in 1:t){
    Storage_sd[1,i ] <- sd(pair_averages_Storage_GCL[ ,i])
    Storage_sd[2,i ] <- sd(pair_averages_Storage_LWG[ ,i])
    
    Forebay_sd[1,i ] <- sd(pair_averages_Forebay_GCL[ ,i])
    Forebay_sd[2,i ] <- sd(pair_averages_Forebay_LWG[ ,i])
    
    Energy_sd[1,i ] <- sd(pair_averages_Energy_GCL[ ,i])
    Energy_sd[2,i ] <- sd(pair_averages_Energy_LWG[ ,i])
  } 
  Storage_sd[3, ] <- 0*c(1:t)
  Forebay_sd[3, ] <- 0*c(1:t)
  Energy_sd[3, ] <- 0*c(1:t)
  mean_sim <- rbind(Storage_mean, Forebay_mean, Energy_mean)
  sd_sim <- rbind(Storage_sd, Forebay_sd, Energy_sd)
  
  mean_sd_sim_antithetic <- list("Means" = mean_sim, "Std dev" = sd_sim, "Storage realizations" = Storage_largerealizations, "Forebay realizations" = Forebay_largerealizations, "Tailwater realizations" = Tailwater_largerealizations, "Head realizations" = Head_largerealizations, "Energy_realizations" = Energy_largerealizations)
}

#' Quantifying means and standard deviations using Monte Carlo approach.
#'
#' Quantifying means and standard deviations for Storage, Forebay, Tailwater, Head and Energy generation 
#' using Monte Carlo approach.
#' 
#'
#' Quantifying means and standard deviations for Storage, Forebay, Tailwater, Head and Energy generation 
#' using Monte Carlo approach. This function is required to evaluate robust objective function and validate
#' probabilistic constraints
#'
#' @param samples A large list of \code{ntimes} random normal samples of Inflows and \code{ntimes^2} random uniform samples of Price for \code{t} = 14 days.
#' For example, in the samples of Inflows to Grand Coulle reservoir (GCLInflowsdata_samples)
#' inside the list, each rows represent a single realization, \code{ntimes} and each columns represent the time steps,\code{t} in days 
#' @param Storage_initial A vector of length 3 with initial/current storage of Grand Coulee, Lower Granite and McNaire.
#' for all \code{t} days. This is provided in the model as initial condition of the optimization.
#' @param Inflow_initial A vector of length 3 with initial/current inflows of Grand Coulee, Lower Granite and McNaire.
#' for all \code{t} days. This is provided in the model as initial condition of the optimization.
#' @param Outflow_initial A vector of length 3 with initial/current outflows of Grand Coulee, Lower Granite and McNaire.
#' for all \code{t} days. This is provided in the model as initial condition of the optimization.
#' @param Forebay_initial A vector of length 3 with initial/current forebay of Grand Coulee, Lower Granite and McNaire.
#' for all \code{t} days. This is provided in the model as initial condition of the optimization.
#' @param Tailwater_initial A vector of length 3 with initial/current tailwater of Grand Coulee, Lower Granite and McNaire.
#' for all \code{t} days. This is provided in the model as initial condition of the optimization.
#' @param Outflows The is the matrix tranformation of outflows data (decision variables) generated by SQP algorithm in a vector form.
#' where each column is the day for \code{t} days optimization period. The rows represents the outflows of GCL,
#' LWG and MCN respectively.
#' @param Fb_coeff This is coefficients to calculate the Forebay. The coefficients are provided as input data and the values
#' has been obtained separately by the regression model. Each row is the coefficient data for GCL, LWG and MCN respectively. 
#' @param Tw_coeff This is coefficients to calculate the Tailwater. The coefficients are provided as input data and the values
#' has been obtained separately by the regression model. Each column is the coefficient data for GCL, LWG and MCN respectively.
#' @param delta_t This is value of time-step in day. In our problem, we have considered daily timesteps for optimization.
#' Therefore, \code{delta_t} =1
#' @param efficiency This is considered as 0.75.
#' @param t An integer indicating the number of timesteps. If we consider daily timestep for 14 day optimization
#' period, \code{t} = 14. 
#' @param r An integer indicating the number of reservoirs. In this case study, \code{r}=3
#' @param n_samples An integer indicating the number of simulations/realizations.
#' 
#'
#' @return A large list of simulations along with the mean and standard deviation
#' for Storage, Forebay, Energy etc. For example, in the simulation matrix of Energy (Energy_realizations) inside the list, each rows
#' represent a single realization, \code{2*ntimes+1} and each columns represent the time steps,\code{t} in days.
#' The first \code{ntimes} rows are the simulations for GrandCoulee, next \code{ntimes} rows are the simulations for Lower Granite
#' and the last row of the matrix is the deterministic Energy generation data for McNaire. McNaire Inflows doesnot have any uncertainity
#' since it is the total outflows released from GCL and LWG which are deterministic. In future, we can introduce other source
#' of uncertainity in the inflows of McNaire.  
#' @export
#'
#' @examples
#' samples <- samples
#' Storage_initial <- Current_Storage
#' Inflow_initial <- Current_Inflows
#' Outflow_initial <- Current_Outflows
#' Forebay_initial <- Current_Forebay
#' Tailwater_initial <- Current_Tailwater
#' Outflows <- Outflows_matrixform
#' Fb_coeff <- Fb_coeff
#' Tw_coeff <- Tw_coeff
#' delta_t <- 1
#' efficieny <- 0.75
#' t <- 14
#' r<- 3
#' n_samples <-500
#' mean_sd_sim(samples, Storage_initial, Inflow_initial, Outflow_initial,  Forebay_initial, Tailwater_initial, Outflows, Fb_coeff, Tw_coeff, delta_t, efficieny, t, r, n_samples)


mean_sd_sim <- function(samples, Storage_initial, Inflow_initial, Outflow_initial,  Forebay_initial, Tailwater_initial, Outflows, Fb_coeff, Tw_coeff, delta_t, efficieny, t, r, n_samples){
  #MC approach
  GCLInflowsdata_samples<- samples$GCLInflowsdata_samples
  LWGInflowsdata_samples<- samples$LWGInflowsdata_samples
  #browser()
  Storage_largerealizations <- Storage_realizations(GCLInflowsdata_samples, LWGInflowsdata_samples, Storage_initial, Inflow_initial, Outflow_initial, Outflows, delta_t, t, n_samples)
  
  #browser()
  Forebay_largerealizations <- Forebay_realizations(Storage_largerealizations, Fb_coeff, t, n_samples)
  
  Tailwater_largerealizations <- Tailwater_realizations(Forebay_largerealizations, Outflow_initial,  Forebay_initial, Tailwater_initial, Tw_coeff, Outflows, t, n_samples)
  
  Head_largerealizations <- Head_realizations(Forebay_largerealizations, Tailwater_largerealizations)
  
  Energy_largerealizations <- Energy_realizations(Head_largerealizations, Outflows, efficieny, t, n_samples)
  n <- n_samples
  
  Storage_mean <- matrix(0L, nrow =r, ncol = t)
  Storage_mean2 <- matrix(0L, nrow =r, ncol = t)
  Forebay_mean <- matrix(0L, nrow =r, ncol = t)
  Forebay_mean2 <- matrix(0L, nrow =r, ncol = t)
  Energy_mean <- matrix(0L, nrow =r, ncol = t)
  Energy_mean2 <- matrix(0L, nrow =r, ncol = t)
  
  Storage_mean[1, ] <- colMeans(Storage_largerealizations[1:n, ])
  Storage_mean[2, ] <- colMeans(Storage_largerealizations[(n+1):(2*n), ])
  Storage_mean[3, ] <- (Storage_largerealizations[(2*n)+1, ])
  Storage_mean2[1, ] <- colMeans(Storage_largerealizations[1:n, ]^2)
  Storage_mean2[2, ] <- colMeans(Storage_largerealizations[(n+1):(2*n), ]^2)
  Storage_mean2[3, ] <- (Storage_largerealizations[(2*n)+1, ]^2)
  
  Storage_sd <- sqrt(Storage_mean2 - (Storage_mean^2))
  
  Forebay_mean[1, ] <- colMeans(Forebay_largerealizations[1:n, ])
  Forebay_mean[2, ] <- colMeans(Forebay_largerealizations[(n+1):(2*n), ])
  Forebay_mean[3, ] <- (Forebay_largerealizations[(2*n)+1, ])
  Forebay_mean2[1, ] <- colMeans(Forebay_largerealizations[1:n, ]^2)
  Forebay_mean2[2, ] <- colMeans(Forebay_largerealizations[(n+1):(2*n), ]^2)
  Forebay_mean2[3, ] <- (Forebay_largerealizations[(2*n)+1, ]^2)
  
  Forebay_sd <- sqrt(Forebay_mean2 - (Forebay_mean^2))
  
  Energy_mean[1, ] <- colMeans(Energy_largerealizations[1:n, ])
  Energy_mean[2, ] <- colMeans(Energy_largerealizations[(n+1):(2*n), ])
  Energy_mean[3, ] <- (Energy_largerealizations[(2*n)+1, ])
  Energy_mean2[1, ] <- colMeans(Energy_largerealizations[1:n, ]^2)
  Energy_mean2[2, ] <- colMeans(Energy_largerealizations[(n+1):(2*n), ]^2)
  Energy_mean2[3, ] <- (Energy_largerealizations[(2*n)+1, ]^2)
  
  Energy_sd <- sqrt(Energy_mean2 - (Energy_mean^2))
  
  mean_sim <- rbind(Storage_mean, Forebay_mean, Energy_mean)
  sd_sim <- rbind(Storage_sd, Forebay_sd, Energy_sd)
  
  mean_sd_sim <- list("Means" = mean_sim, "Std dev" = sd_sim, "Storage realizations" = Storage_largerealizations, "Forebay realizations" = Forebay_largerealizations, "Tailwater realizations" = Tailwater_largerealizations, "Head realizations" = Head_largerealizations, "Energy_realizations" = Energy_largerealizations)
}

